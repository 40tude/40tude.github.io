---
layout: default
parent: "Simple OS"
title: "SOS 2 le retour 20 ans apr√®s... Episode 1"
math: mathjax
date: 2023-11-19 00:20:43
last_modified_date: 2023-12-04 00:02:38
---
<div align="center">
<img src="./assets/image-2.webp" alt="" width="900" loading="lazy"/>
</div>

## **Cr√©ez votre OS**

En 2004, rappelez-vous, c'√©tait l'ann√©e des Black Eyed Peas, de la sortie du film le prisonnier d'Azkaban, de l'atterrissage de Opportunity sur Mars... Le noyau Linux √©tait en 2.6 et Chirac √©tait pr√©sident... Toute une √©poque... En plus, en juin de cette ann√©e-l√†, avec le num√©ro 62 de GNU Linux Magazine France, a d√©but√© une s√©rie d'articles dont l'objectif √©tait d'expliquer comment on pouvait √©crire son propre syst√®me d'exploitation (SOS comme [Simple OS](http://sos.enix.org/fr/SOSDownload)). Je ne sais pas pourquoi, mais il y a des articles et des sujets qui vous restent dans la t√™te...

<div align="center">
<img src="./assets/image-5_1.webp" alt="" width="900" loading="lazy"/>
</div>


Par exemple, √† la fin du premier √©pisode de la s√©rie (je pense qu'on peut m√™me parler de saga...) on √©tait capable de faire booter SOS et on avait d√©j√† un affichage √† l'√©cran.

<div align="center">
<img src="./assets/image-1.webp" alt="" width="900" loading="lazy"/>
</div>


Sans divulguer la fin de l'histoire (mais oui, oui, ils vont se marier et avoir beaucoup d'enfants), la s√©rie s'est d√©ploy√©e sur 13 articles de juin 2004 √† octobre 2007. Sauf erreur de ma part, rien n'a √©t√© publi√© par la suite (c'est dommage, j'attendais avec impatience l'impl√©mentation de la stack r√©seau).

Heu... Non, non je ne suis pas nostalgique. Je n'aime pas particuli√®rement les voitures anciennes, je pr√©f√®re bien mieux [ma r√©cente RSV4](https://www.40tude.fr/category/rsv4-sur-circuit/) √† une vieille [RG 500 Gama](https://www.motoplanete.com/suzuki/3154/RG-500-GAMMA-1985/contact.html). Cela dit, je trouve que pour ceux qui veulent comprendre ce qui se passe au d√©marrage d'un PC et/ou ce qui se cache dans un operating system, cette s√©rie reste d'actualit√© et peut √™tre une excellente base de d√©part.

### **Quelles sont les caract√©ristiques de SOS ?**

* 32 bits, mode prot√©g√©

* Pas pr√©emptif, monolithique

* Chargement par Grub 1 et multiboot 1

* Pagination m√©moire

* Pas de swap

* Gestion des IT

* Clavier, √©cran, driver disque dur

* Partitions, Virtual File System

* Pas d'interface r√©seau

* Processus, threads, pas de DLL

* On part de 0 et tout est fait "maison"

Si √† ce stade, il y a des caract√©ristiques qui te passent au-dessus de la t√™te, ce n'est pas tr√®s grave. Dis-toi que pour un OS "maison" c'est d√©j√† vraiment bien et que cela va te permettre d'aborder beaucoup de sujets qui t'aideront √† mieux comprendre les OS d'aujourd'hui.

Sinon... Le site de r√©f√©rence est [sur cette page](http://sos.enix.org/fr/SOSDownload#TOC_0_2_1). On y trouve les PDF et les codes des diff√©rents articles. Attention, pour l'√©pisode 10, le source est bien sur la page pr√©c√©dente mais pas l'article. On peut toutefois retrouver ce dernier sur [cette page](https://www.abandonware-magazines.org/affiche_mag.php?mag=303&page=8) (il faut alors prendre le N¬∞98 d'octobre). Ce ne sera pas un beau PDF mais plut√¥t une suite d'images. J'ai essay√© de retrouver les num√©ros sur le site de [Linux Mag](https://connect.ed-diamond.com/gnu-linux-magazine) mais sans succ√®s.

## **L'objectif de ce billet**

Faire red√©marrer SOS en utilisant des moyens contemporains.

* Docker

* Grub 2 et multiboot 2

* Git

* QEMU (derni√®re version)

* NASM (au lieu de GAS dans les articles de l'√©poque)

* VSCode

* Eviter de tout casser et de tout r√©√©crire. Rester respectueux et humble devant ce qui a √©t√© √©crit.

* √ätre ind√©pendant de l'OS qu'utilise le lecteur

L√† aussi, si certains sujets ne sont pas encore tr√®s clairs, pas d'angoisse on aura l'occasion de revenir dessus. Oui, bien s√ªr, beaucoup de choses ont √©volu√© : 64 bits partout, UEFI, NVMe, Git a vu le jour, plus de lecteur de disquette dans les PC, plus de CD dans les magazines etc. N'emp√™che, tout ce qui est dit dans les articles, tout ce qui y est expliqu√© reste valable en grande partie encore aujourd'hui. Cerise sur le g√¢teau pour certains, tout est en fran√ßais (j'ai pens√© √©crire ce billet en anglais mais ce n'√©tait pas raccord avec les articles alors, j'ai laiss√© tomber l'id√©e).

### **Note**

Si tu veux avoir une id√©e de ce qu'il faut faire en 2023 pour faire tourner SOS dans une configuration similaire √† celle de l'√©poque, tu peux [lire ce billet](https://www.40tude.fr/sos-2-le-retour-20-ans-apres/). Good luck, ce sera sans moi. üòä

## **Qu'est-ce qui tourne aujourd'hui ?**

Cet apr√®s-midi (18 nov. 2023) j'ai r√©ussi √† mettre en route le code de l'√©pisode 1. Voil√† par exemple ce que j'√©tais capable d'afficher lors du boot.

<div align="center">
<img src="./assets/image-4.webp" alt="" width="900" loading="lazy"/>
</div>


Th√©oriquement et sauf grosse mauvaise surprise le plus gros du travail est fait.

* Les diff√©rents outils sont en place (arborescence des fichiers, compilateur, linker, Makefile...)

* Les codes qui devaient √™tre adapt√©s sont, eux aussi, en place

* √Ä mon avis, on n'est pas trop mal. Je m'attends √† ce que dans les autres articles il y ait principalement du code C auquel on n'aura pas besoin de trop toucher. Oui, c'est s√ªr, il y aura bien une petite louche d'assembleur ici ou l√†, mais √ßa devrait bien se passer. J'y crois.

## **C'est quoi la suite ?**

D√©j√†, je vais pr√©ciser le vocabulaire. √Ä partir de maintenant j'appelle **SOS**, le syst√®me d'exploitation "canal historique", le vrai, celui dont il est question dans les articles. Ensuite, j'appelle **SOS2** (sans espace) la version de SOS qu'on va adapter √† nos besoins.

Ok mais la suite c'est quoi ? Je vais repartir d'une page blanche, refaire toutes les √©tapes et tout mettre par √©crit au fur et √† mesure. Pendant ce temps-l√†, je te propose de :

* [R√©cup√©rer l'article 1](http://sos.enix.org/fr/SOSDownload#TOC_0_2_25) et de l'imprimer (pas la peine de r√¢ler, 66% du papier est recycl√©)

* Le lire de mani√®re "active" en prenant des notes, beaucoup de notes, dans les marges

* De ne pas passer trop de temps sur la section 4.2.3 qui traite du boot avec le secteur de boot d'une diskette. C'est instructif mais nous on ne va pas faire √ßa. En effet, SOS2 sera charg√© en m√©moire par Grub 2 (voir la section 4.2.2 de l'article).

* Suite √† la lecture de l'article (pas de soucis si tu dois le lire 2 ou 3 fois, c'est dense, tr√®s dense), n'h√©site pas √† aller faire le plein d'informations compl√©mentaires sur le web. En effet, je ne vais ni reprendre ni revenir le contenu des articles. Ce n'est pas l'objet de ce billet. Rappelle-toi Barbara, moi ce que je veux, c'est que le code "historique" puisse tourner √† nouveau.

Je pense que ce billet, celui de l'√©pisode 1, va √™tre le plus long car c'est ici qu'on va mettre la "toolchain" en place, faire les adaptations pour le support de Grub 2 et de multiboot 2. On va aussi modifier le makefile, traduire et adapter des fichiers assembleur etc. Quand ce travail pr√©liminaire indispensable sera termin√© et que tout sera en place j'esp√®re qu'on pourra facilement transposer les autres √©pisodes. On verra, on n'y est pas encore.

## **1 - Installation des outils**

Je suis sous [Windows 11 (23H2)](https://www.40tude.fr/finalize-windows-11-installation-2/) mais c'est exactement la m√™me chose si tu es sous Linux (j'ai un [host mint 21.2](https://github.com/40tude/mint_config_latitude))

### **WIN11**

#### **Installer Docker**

Soit, tu vas sur [le site de Docker](https://www.docker.com/products/docker-desktop/), soit, si tu as install√© l'excellent [choco](https://chocolatey.org/). Dans ce cas tu saisis les 2 lignes ci-dessous dans un terminal PowerShell en **mode Administrateur** (WIN+X puis A). √Ä propos de choco tu peux [aller sur cette page](https://www.40tude.fr/how-to-install-windows-11-with-a-usb-key/) et y rechercher le mot "choco". La proc√©dure d'installation y est expliqu√©e. Pour le reste Docker doit demander que l'on s'enregistre √† un moment ou √† un autre.

```powershell
choco install docker-desktop -y
Update-SessionEnvironment
```

Je crois qu'apr√®s l'installation de Docker il faut red√©marrer. Je ne suis plus s√ªr. Si c'est le cas, attends d'avoir install√© QEMU et VSCode.

#### **Installer QEMU**

Tu peux aller [sur cette page](https://www.qemu.org/download/) ou taper la ligne ci-dessous dans le terminal Admin d√©j√† ouvert :

```powershell
choco install qemu -y
```
#### **Installation de VSCode**

Pareil. Pilule bleue ou pilule rouge. Soit, tu vas sur [la page de VSCode](https://code.visualstudio.com/download) soit tu tape cette ligne :

```powershell
choco install vscode -y
```

Ensuite

* Red√©marre si besoin

* Quand c'est fait, assure-toi que tu arrives √† lancer les 3 outils.
  + Dans une console normale (WIN+X puis I)

  + Tape : `code .`

  + Fermes ensuite la fen√™tre VSCode

  + Tape : `qemu-system-i386`

  + Ferme la fen√™tre de l'√©mulateur qui pleure car il ne trouve pas d'OS √† faire d√©marrer

  + Tape : `docker --help`

  + S'il pleut ou si tu n'as pas d'amis lis ce qui est √©crit, sinon passe √† la suite...

### **LINUX**

#### **Installer Docker**

```bash
sudo apt install docker docker-compose docker-doc docker-registry docker.io -y
sudo usermod -aG docker $USER
```
#### **Installer QEMU**

```bash
sudo apt install qemu-system -y
```
#### **Installation de VSCode**

```bash
sudo apt install dirmngr ca-certificates software-properties-common apt-transport-https -y
curl -fSsL https://packages.microsoft.com/keys/microsoft.asc | sudo gpg --dearmor | sudo tee /usr/share/keyrings/vscode.gpg > /dev/null
echo deb [arch=amd64 signed-by=/usr/share/keyrings/vscode.gpg] https://packages.microsoft.com/repos/vscode stable main | sudo tee /etc/apt/sources.list.d/vscode.list
sudo apt update
sudo apt install code -y
```

Ensuite

* Red√©marre si besoin

* Quand c'est fait, assure-toi que tu arrives √† lancer les 3 outils.
  + Dans une console

  + Tape : `code .`

  + Fermes ensuite la fen√™tre VSCode

  + Tape : `qemu-system-i386`

  + Ferme alors la fen√™tre de l'√©mulateur qui pleure car il ne trouve pas d'OS √† faire d√©marrer

  + Tape : `docker --help`

  + S'il pleut ou si tu n'as pas d'amis lis ce qui est √©crit, sinon passe √† la suite...

## **2 - Cr√©ation des r√©pertoires du projet**

### **Comment √ßa va se passer ?**

* T'inqui√®te paupiette, √ßa va bien se passer...

* Comme il y a peu ou pas d'int√©r√™t √† mettre par √©crit toutes les instructions √† suivre, on va utiliser un script.

* Ce dernier va :
  + Cr√©er un sous-r√©pertoire `sos2`

  + Aller chercher le code de SOS de l'article 1 et le mettre dans un sous-r√©pertoire `download`

  + Cr√©er les diff√©rents sous-r√©pertoires dont on aura besoin plus tard

  + Copier, depuis le sous-r√©pertoire `download` les sources qu'on va utiliser pour cr√©er SOS2

  + Cr√©er un fichier `.gitignore` (utile si tu as git sur ta machine)

√Ä l'issue du script on sera plac√© dans le sous-r√©pertoire `sos2` et on pourra vraiment commencer.

### **WIN11**

* D√©place-toi dans le r√©pertoire dans lequel tu veux cr√©er le sous-r√©pertoire `sos2` qui contiendra le projet SOS2
  + Exemple : `C:\Users\phili\OneDrive\Documents\Tmp`

* Copie colle le code ci-dessous dans un script `sos2.ps1` dans le r√©pertoire en question
  + Exemple : `C:\Users\phili\OneDrive\Documents\Tmp\sos2.ps1`

```powershell
New-Item sos2 -ItemType Directory
Set-Location sos2
New-Item download -ItemType Directory
Invoke-WebRequest -URI http://sos.enix.org/wiki-fr/upload/SOSDownload/sos-code-art1.tgz -OutFile ./download/sos-code-art1.tgz
tar -xvzf ./download/sos-code-art1.tgz -C ./download
New-Item build -ItemType Directory
New-Item buildenv -ItemType Directory
New-Item target/iso/boot/grub -ItemType Directory
Copy-Item ./download/sos-code-article1/bootstrap ./bootstrap -Recurse
Copy-Item ./download/sos-code-article1/drivers ./drivers -Recurse
Copy-Item ./download/sos-code-article1/hwcore ./hwcore -Recurse
Copy-Item ./download/sos-code-article1/sos ./sos -Recurse
"dist/
build/" | Out-File -FilePath ./.gitignore.txt -Encoding ascii
```

* Note les pr√©cautions que prend le script avec le type d'encodage du fichier `.gitignore`. Git semble en effet incapable de g√©rer correctement un fichier `.gitignore` encod√© en UTF. Il faut donc g√©n√©rer ce dernier en ASCII basique. J'en parle car il m'a fallu pas mal de temps avant de r√©aliser ce qui se passait.

* Voil√† ce que cela peut donner dans un terminal avant qu'on appelle le script

<div align="center">
<img src="./assets/image-5.webp" alt="" width="900" loading="lazy"/>
</div>


* Lance le script `sos2.ps1`

* √Ä la fin, on se retrouve dans le r√©pertoire `sos2` qui est organis√© de la fa√ßon suivante

<div align="center">
<img src="./assets/image-6.webp" alt="" width="900" loading="lazy"/>
</div>


* Si jamais PowerShell r√¢le pour des raisons de s√©curit√©...
  + Ouvrir un terminal en mode Administrateur et saisir la commande ci-dessous qui autorise l'ex√©cution des scripts cr√©√©s localement mais qui demande que les scripts qui viennent de l'ext√©rieur soient sign√©s.

```bash
#!/usr/bin/env bash
mkdir ./sos2
cd ./sos2
mkdir ./download
wget -P ./download http://sos.enix.org/wiki-fr/upload/SOSDownload/sos-code-art1.tgz
tar -xvzf ./download/sos-code-art1.tgz -C ./download
mkdir ./build
mkdir ./buildenv
mkdir -p ./target/iso/boot/grub
cp -r ./download/sos-code-article1/bootstrap ./bootstrap
cp -r ./download/sos-code-article1/drivers ./drivers
cp -r ./download/sos-code-article1/hwcore ./hwcore
cp -r ./download/sos-code-article1/sos ./sos
echo "dist/
build/" > .gitignore
```

* Etat du r√©pertoire avant d'avoir lanc√© le script

<div align="center">
<img src="./assets/image-29.webp" alt="" width="900" loading="lazy"/>
</div>


* Lance le script `sos2.sh` (n'oublie pas le point devant, je l'oublie toujours...)

```bash
. sos2.sh
```

* √Ä la fin, on se retrouve dans le r√©pertoire `sos2` qui est organis√© de la fa√ßon suivante

<div align="center">
<img src="./assets/image-30.webp" alt="" width="900" loading="lazy"/>
</div>

### **Organisation des r√©pertoires de travail**

Je ne reviens pas sur les r√©pertoires de SOS (`./bootstrap`, `./drivers`, `./hwcore` et `./sos`)

* `./build` : va contenir les fichiers compil√©s (.o). √áa √©vite d'avoir des fichiers .o qui "trainent" dans les r√©pertoires `./bootstrap`, `./sos` etc. On verra par la suite si au lieu de tout mettre "√† plat" dans `./build` on ne cr√©√© pas des sous r√©pertoires du style `./build/sos`, `./build/drivers` etc.

* `./buildenv` : c'est dans ce r√©pertoire qu'on va √©crire le fichier en charge de cr√©er l'environnement dans lequel on va compiler, linker puis graver sur CD virtuel SOS2. On en parle dans 2 minutes. C'est par lui qu'on va commencer.

* `./download` : on en a d√©j√† parl√© bri√®vement. C'est l√† qu'on met une copie des sources de SOS de l'√©pisode en question. Ici le 1 par exemple.

* `./target` : un r√©pertoire dont va avoir besoin `[grub-mkrescue](https://www.gnu.org/software/grub/manual/grub/html_node/Invoking-grub_002dmkrescue.html)` afin de cr√©er l'image .iso de SOS2. On en reparle au moment de la r√©daction du `Makefile`.

## **3 - Modifications des fichiers du projet**

Bon, √† partir de l√†, que tu sois sur un host Windows ou Linux la fa√ßon de proc√©der va √™tre identique. C'est tant mieux car cela va simplifier la r√©daction du billet. Allez, on ne perd pas de temps et on lance VSCode depuis un terminal :

```powershell
code .
```
<div align="center">
<img src="./assets/image-7.webp" alt="" loading="lazy"/>
</div>

### **Cr√©ation du buildenv**

* Dans le r√©pertoire `buildenv`

* On va cr√©er un fichier `Dockerfile` dans lequel on va copier les lignes ci-dessous

```powershell
docker build buildenv -t sos2-buildenv
```

Voil√† ce que je vois :

<div align="center">
<img src="./assets/image-9.webp" alt="" width="900" loading="lazy"/>
</div>

#### **S√©quence explications :**

* Docker permet de faire tourner des **images** qui, comme les vraies photos sont des instantan√©s.
  Autrement dit, dans le monde Docker, une image c'est un groupe de logiciels qu'on a mis ensemble. Un peu comme les invit√©s sur une photo de mariage. Ceci dit, la configuration est fig√©e. Les invit√©s auront toujours le m√™me √¢ge sur la photo de m√™me que les logiciels auront toujours les m√™mes versions dans l'image Docker.

* Ce qui est vraiment cool avec Docker et qu'on ne peut pas faire avec une photo, c'est qu'on peut prendre l'image et la faire "tourner", la faire "rouler" au sein d'un OS (Linux bien souvent). Quand on a une image qui tourne, on appelle √ßa un **container**. On doit sans doute dire conteneur en FR mais je vais continuer √† √©crire container.
  L'exemple classique c'est celui d'un d√©veloppeur qui utilise 12 000 biblioth√®ques pour son d√©veloppement et une configuration bien pourrie que personne n'arrive √† reproduire. Si la config n'est disponible que sur le disque dur du d√©veloppeur c'est mort. Personne ne peut mettre en route l'application car personne ne sait comment installer tout ce qui est n√©cessaire (dans quel ordre, quelles versions, o√π...). Cependant si l'application et les biblioth√®ques sont dans une image Docker, bingo ! Passe-moi l'image, je peux la mettre en route dans un container sur mon PC et zou je peux tester l'application, donner du feedback etc.

* Donc, en fran√ßais dans le texte, dans le projet SOS2, on utilise Docker pour cr√©er une image. Cette image s'apppuie elle-m√™me sur une configuration Linux √©quip√©e du compilateur gcc (voir la ligne 1 du Dockerfile). Ensuite on rajoute sur cette image pr√©existante, deux ou trois trucs dont on a besoin (nasm, grub...) et zou on est pr√™t. Pour les curieux qui se demandent d'o√π provient l'image gcc sur laquelle on s'appuie je vous propose d'aller faire un tour sur le site [Docker Hub](https://hub.docker.com/_/gcc) (je crois que l√† aussi faut s'enregistrer).

* La ligne de commande qu'on saisit ensuite demande √† Docker de construire l'image qui s'appellera `sos2-buildenv`.

* Sur ton terminal l'affichage sera diff√©rent car moi, j'ai d√©j√† construit l'image plusieurs fois d√©j√† et tout est en cache. Pas de panique si rien ne bouge au d√©but. Il faut que Docker aille chercher l'image gcc sur le net, fasse des v√©rifications etc.

* Attention c'est une image (une photo), il n'y a encore rien qui tourne.

### **Lancement du container**

Toujours dans le terminal de VSCode il faut maintenant saisir la commande suivante :

#### **Windows**

Attention au '/' avant les 2 points

```powershell
docker run --rm -it -v $pwd/:/root/env sos2-buildenv
```
#### **Linux**

Attention aux '(' et ')' autour de `pwd`

```bash
docker run --rm -it -v $(pwd):/root/env sos2-buildenv
```
#### **S√©quence explications**

La ligne dit :

* Fais tourner l'image qui s'appelle `sos2-buildenv`

* Fais la tourner en mode interactif `-it`

* Quand on en aura termin√©, pense √† supprimer le container `-rm` (l'image, elle, sera conserv√©e)

* D√©brouille-toi pour que le contenu du r√©pertoire local (`$pwd`, process working directory) corresponde au r√©pertoire `/root/env` du container. Heu... Il est donc tr√®s important d'invoquer cette ligne de commande depuis le r√©pertoire `sos2` de l'h√¥te.

Voil√† ce que je vois quand je lance la commande. Le prompt a chang√©. Je suis `root` (le ma√Ætre du monde, vizir √† la place du vizir mais bon, un grand pouvoir implique de grandes responsabilit√©s). La machine s'appelle `f284af14db9e` et je suis dans le r√©pertoire `~/env` (voir si besoin les 2 derni√®res lignes du fichier Dockerfile).

<div align="center">
<img src="./assets/image-10.webp" alt="" loading="lazy"/>
</div>


Si je tape `ls` puis `gcc --version` dans ce terminal, voil√† ce que je vois

<div align="center">
<img src="./assets/image-11.webp" alt="" width="900" loading="lazy"/>
</div>


Le container est donc une machine Linux √©quip√©e d'un compilateur gcc plus deux ou trois bricoles que je peux utiliser pour compiler du code etc.

#### **Note importante :**

* Il faut comprendre que tous les fichiers qui seront g√©n√©r√©s dans le r√©pertoire `~/env` du container se retrouveront dans le r√©pertoire `$pwd` du host Windows ou Linux. Par exemple sous Windows √ßa peut √™tre un chemin du style : `C:\Users\phili\OneDrive\Documents\Tmp\sos2`

√áa c'est super cool car √† chaque lancement du container on aura la m√™me config soft mais on pourra sauver notre travail (persistance) sur le disque dur du host.

Si on veut un autre terminal "local", dans VScode il suffit d'appuyer sur le "+" au bout √† droite. On voit alors qu'il y a un d√©j√† terminal nomm√© `docker` et un autre qui se nomme `pwsh` (je suis sous Win11). Voil√† ce que je vois si je tape la commande `ls` :

<div align="center">
<img src="./assets/image-12.webp" alt="" width="900" loading="lazy"/>
</div>


Pour quitter le container docker, il suffit de l'activer et de saisir la commande `exit`.

Si plus tard on veut relancer le container, il suffit de relancer la commande ci-dessous (pas besoin de refaire une image `sos2-buildenv` car celle-ci existe d√©j√†).

```powershell
docker run --rm -it -v $pwd/:/root/env sos2-buildenv
```
```bash
docker run --rm -it -v $(pwd):/root/env sos2-buildenv
```

En revanche, si on voulait ajouter une lib, un outil √† l'image, alors dans ce cas il suffirait de modifier le fichier Dockerfile, de reconstruire une image (avec le m√™me nom ou pas) puis de refaire un `docker run`.

Histoire qu'on soit bien synchronis√©s, je te propose de quitter (exit) le container et de fermer l'autre terminal si besoin. On va s'int√©resser maintenant au r√©pertoire `bootstrap`.

### **Support de Grub 2 et de multiboot 2 dans bootstrap**

Dans le r√©pertoire /bootstrap on va :

2. Renommer les fichiers existants en .bak. Il suffit d'appuyer sur F2 une fois que le nom d'un fichier est s√©lectionn√© puis de le renommer.

6. Cr√©er un fichier multiboot.asm

10. Cr√©er un fichier multiboot_header.asm

Voil√† ce que cela donne chez moi

<div align="center">
<img src="./assets/image-13.webp" alt="" loading="lazy"/>
</div>


Dans le fichier multiboot_header.asm, colle les lignes suivantes :

```c
/* multiboot2.h - Multiboot 2 header file. */
/* Copyright (C) 1999,2003,2007,2008,2009,2010 Free Software Foundation, Inc.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL ANY
* DEVELOPER OR DISTRIBUTOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
* IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
#ifndef MULTIBOOT_HEADER
#define MULTIBOOT_HEADER 1
/* How many bytes from the start of the file we search for the header. */
#define MULTIBOOT_SEARCH 32768
#define MULTIBOOT_HEADER_ALIGN 8
/* The magic field should contain this. */
#define MULTIBOOT2_HEADER_MAGIC 0xe85250d6
/* This should be in %eax. */
#define MULTIBOOT2_BOOTLOADER_MAGIC 0x36d76289
/* Alignment of multiboot modules. */
#define MULTIBOOT_MOD_ALIGN 0x00001000
/* Alignment of the multiboot info structure. */
#define MULTIBOOT_INFO_ALIGN 0x00000008
/* Flags set in the ‚Äôflags‚Äô member of the multiboot header. */
#define MULTIBOOT_TAG_ALIGN 8
#define MULTIBOOT_TAG_TYPE_END 0
#define MULTIBOOT_TAG_TYPE_CMDLINE 1
#define MULTIBOOT_TAG_TYPE_BOOT_LOADER_NAME 2
#define MULTIBOOT_TAG_TYPE_MODULE 3
#define MULTIBOOT_TAG_TYPE_BASIC_MEMINFO 4
#define MULTIBOOT_TAG_TYPE_BOOTDEV 5
#define MULTIBOOT_TAG_TYPE_MMAP 6
#define MULTIBOOT_TAG_TYPE_VBE 7
#define MULTIBOOT_TAG_TYPE_FRAMEBUFFER 8
#define MULTIBOOT_TAG_TYPE_ELF_SECTIONS 9
#define MULTIBOOT_TAG_TYPE_APM 10
#define MULTIBOOT_TAG_TYPE_EFI32 11
#define MULTIBOOT_TAG_TYPE_EFI64 12
#define MULTIBOOT_TAG_TYPE_SMBIOS 13
#define MULTIBOOT_TAG_TYPE_ACPI_OLD 14
#define MULTIBOOT_TAG_TYPE_ACPI_NEW 15
#define MULTIBOOT_TAG_TYPE_NETWORK 16
#define MULTIBOOT_TAG_TYPE_EFI_MMAP 17
#define MULTIBOOT_TAG_TYPE_EFI_BS 18
#define MULTIBOOT_TAG_TYPE_EFI32_IH 19
#define MULTIBOOT_TAG_TYPE_EFI64_IH 20
#define MULTIBOOT_TAG_TYPE_LOAD_BASE_ADDR 21
#define MULTIBOOT_HEADER_TAG_END 0
#define MULTIBOOT_HEADER_TAG_INFORMATION_REQUEST 1
#define MULTIBOOT_HEADER_TAG_ADDRESS 2
#define MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS 3
#define MULTIBOOT_HEADER_TAG_CONSOLE_FLAGS 4
#define MULTIBOOT_HEADER_TAG_FRAMEBUFFER 5
#define MULTIBOOT_HEADER_TAG_MODULE_ALIGN 6
#define MULTIBOOT_HEADER_TAG_EFI_BS 7
#define MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS_EFI32 8
#define MULTIBOOT_HEADER_TAG_ENTRY_ADDRESS_EFI64 9
#define MULTIBOOT_HEADER_TAG_RELOCATABLE 10
#define MULTIBOOT_ARCHITECTURE_I386 0
#define MULTIBOOT_ARCHITECTURE_MIPS32 4
#define MULTIBOOT_HEADER_TAG_OPTIONAL 1
#define MULTIBOOT_LOAD_PREFERENCE_NONE 0
#define MULTIBOOT_LOAD_PREFERENCE_LOW 1
#define MULTIBOOT_LOAD_PREFERENCE_HIGH 2
#define MULTIBOOT_CONSOLE_FLAGS_CONSOLE_REQUIRED 1
#define MULTIBOOT_CONSOLE_FLAGS_EGA_TEXT_SUPPORTED 2
#ifndef ASM_FILE
typedef unsigned char multiboot_uint8_t;
typedef unsigned short multiboot_uint16_t;
typedef unsigned int multiboot_uint32_t;
typedef unsigned long long multiboot_uint64_t;
struct multiboot_header
{
/* Must be MULTIBOOT_MAGIC - see above. */
multiboot_uint32_t magic;
/* ISA */
multiboot_uint32_t architecture;
/* Total header length. */
multiboot_uint32_t header_length;
/* The above fields plus this one must equal 0 mod 2^32. */
multiboot_uint32_t checksum;
};
struct multiboot_header_tag
{
multiboot_uint16_t type;
multiboot_uint16_t flags;
multiboot_uint32_t size;
};
struct multiboot_header_tag_information_request
{
multiboot_uint16_t type;
multiboot_uint16_t flags;
multiboot_uint32_t size;
multiboot_uint32_t requests[0];
};
struct multiboot_header_tag_address
{
multiboot_uint16_t type;
multiboot_uint16_t flags;
multiboot_uint32_t size;
multiboot_uint32_t header_addr;
multiboot_uint32_t load_addr;
multiboot_uint32_t load_end_addr;
multiboot_uint32_t bss_end_addr;
};
struct multiboot_header_tag_entry_address
{
multiboot_uint16_t type;
multiboot_uint16_t flags;
multiboot_uint32_t size;
multiboot_uint32_t entry_addr;
};
struct multiboot_header_tag_console_flags
{
multiboot_uint16_t type;
multiboot_uint16_t flags;
multiboot_uint32_t size;
multiboot_uint32_t console_flags;
};
struct multiboot_header_tag_framebuffer
{
multiboot_uint16_t type;
multiboot_uint16_t flags;
multiboot_uint32_t size;
multiboot_uint32_t width;
multiboot_uint32_t height;
multiboot_uint32_t depth;
};
struct multiboot_header_tag_module_align
{
multiboot_uint16_t type;
multiboot_uint16_t flags;
multiboot_uint32_t size;
};
struct multiboot_header_tag_relocatable
{
multiboot_uint16_t type;
multiboot_uint16_t flags;
multiboot_uint32_t size;
multiboot_uint32_t min_addr;
multiboot_uint32_t max_addr;
multiboot_uint32_t align;
multiboot_uint32_t preference;
};
struct multiboot_color
{
multiboot_uint8_t red;
multiboot_uint8_t green;
multiboot_uint8_t blue;
};
struct multiboot_mmap_entry
{
multiboot_uint64_t addr;
multiboot_uint64_t len;
#define MULTIBOOT_MEMORY_AVAILABLE 1
#define MULTIBOOT_MEMORY_RESERVED 2
#define MULTIBOOT_MEMORY_ACPI_RECLAIMABLE 3
#define MULTIBOOT_MEMORY_NVS 4
#define MULTIBOOT_MEMORY_BADRAM 5
multiboot_uint32_t type;
multiboot_uint32_t zero;
};
typedef struct multiboot_mmap_entry multiboot_memory_map_t;
struct multiboot_tag
{
multiboot_uint32_t type;
multiboot_uint32_t size;
};
struct multiboot_tag_string
{
multiboot_uint32_t type;
multiboot_uint32_t size;
char string[0];
};
struct multiboot_tag_module
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint32_t mod_start;
multiboot_uint32_t mod_end;
char cmdline[0];
};
struct multiboot_tag_basic_meminfo
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint32_t mem_lower;
multiboot_uint32_t mem_upper;
};
struct multiboot_tag_bootdev
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint32_t biosdev;
multiboot_uint32_t slice;
multiboot_uint32_t part;
};
struct multiboot_tag_mmap
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint32_t entry_size;
multiboot_uint32_t entry_version;
struct multiboot_mmap_entry entries[0];
};
struct multiboot_vbe_info_block
{
multiboot_uint8_t external_specification[512];
};
struct multiboot_vbe_mode_info_block
{
multiboot_uint8_t external_specification[256];
};
struct multiboot_tag_vbe
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint16_t vbe_mode;
multiboot_uint16_t vbe_interface_seg;
multiboot_uint16_t vbe_interface_off;
multiboot_uint16_t vbe_interface_len;
struct multiboot_vbe_info_block vbe_control_info;
struct multiboot_vbe_mode_info_block vbe_mode_info;
};
struct multiboot_tag_framebuffer_common
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint64_t framebuffer_addr;
multiboot_uint32_t framebuffer_pitch;
multiboot_uint32_t framebuffer_width;
multiboot_uint32_t framebuffer_height;
multiboot_uint8_t framebuffer_bpp;
#define MULTIBOOT_FRAMEBUFFER_TYPE_INDEXED 0
#define MULTIBOOT_FRAMEBUFFER_TYPE_RGB 1
#define MULTIBOOT_FRAMEBUFFER_TYPE_EGA_TEXT 2
multiboot_uint8_t framebuffer_type;
multiboot_uint16_t reserved;
};
struct multiboot_tag_framebuffer
{
struct multiboot_tag_framebuffer_common common;
union
{
struct
{
multiboot_uint16_t framebuffer_palette_num_colors;
struct multiboot_color framebuffer_palette[0];
};
struct
{
multiboot_uint8_t framebuffer_red_field_position;
multiboot_uint8_t framebuffer_red_mask_size;
multiboot_uint8_t framebuffer_green_field_position;
multiboot_uint8_t framebuffer_green_mask_size;
multiboot_uint8_t framebuffer_blue_field_position;
multiboot_uint8_t framebuffer_blue_mask_size;
};
};
};
struct multiboot_tag_elf_sections
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint32_t num;
multiboot_uint32_t entsize;
multiboot_uint32_t shndx;
char sections[0];
};
struct multiboot_tag_apm
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint16_t version;
multiboot_uint16_t cseg;
multiboot_uint32_t offset;
multiboot_uint16_t cseg_16;
multiboot_uint16_t dseg;
multiboot_uint16_t flags;
multiboot_uint16_t cseg_len;
multiboot_uint16_t cseg_16_len;
multiboot_uint16_t dseg_len;
};
struct multiboot_tag_efi32
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint32_t pointer;
};
struct multiboot_tag_efi64
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint64_t pointer;
};
struct multiboot_tag_smbios
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint8_t major;
multiboot_uint8_t minor;
multiboot_uint8_t reserved[6];
multiboot_uint8_t tables[0];
};
struct multiboot_tag_old_acpi
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint8_t rsdp[0];
};
struct multiboot_tag_new_acpi
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint8_t rsdp[0];
};
struct multiboot_tag_network
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint8_t dhcpack[0];
};
struct multiboot_tag_efi_mmap
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint32_t descr_size;
multiboot_uint32_t descr_vers;
multiboot_uint8_t efi_mmap[0];
};
struct multiboot_tag_efi32_ih
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint32_t pointer;
};
struct multiboot_tag_efi64_ih
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint64_t pointer;
};
struct multiboot_tag_load_base_addr
{
multiboot_uint32_t type;
multiboot_uint32_t size;
multiboot_uint32_t load_base_addr;
};
#endif /* ! ASM_FILE */
#endif /* ! MULTIBOOT_HEADER */
```

Pour la seconde √©tape, il suffit d'ouvrir `main.c` et d'apporter les modifications ci-dessous :

```c
//#include <bootstrap/multiboot.h>
#include <sos/multiboot2.h>
```

Ceci dit, on devra revenir pour modifier le fichier `main.c`. En effet, ce dernier "cause" multiboot 1 alors que nous, on est dor√©navant compatibles multiboot 2. Pas grave, on y reviendra en temps utile.

### **Cr√©ation d'un fichier grub.cfg**

Il suffit de copier le code ci-dessous dans un fichier `grub.cfg` √† d√©poser dans `target\iso\boot\grub\grub.cfg`

```c
#define BOCHS_PRTHEX(q) \
({ unsigned char r; if ((q) >= 10) r='a'+(q)-10; \
else r='0'+(q); sos_bochs_putchar(r); })
```

√Ä :

```c
#define BOCHS_PRTHEX(q) \
({ unsigned char r; if ((q) >= 10) r='a'+(q)-10; else r='0'+(q); sos_bochs_putchar(r); })
```

Quand c'est fait on relance un `make`. Pour le coup il y a moins d'erreurs et c'est `main.c` qui pose probl√®me. Si on lit les messages d'erreur (il faut lire les messages d'erreurs...) √† priori le compilateur ne connait pas `multiboot_info_t`.

<div align="center">
<img src="./assets/image-18.webp" alt="" width="900" loading="lazy"/>
</div>


Allez, CTRL+click sur `sos/main.c:35:3`, on va aller voir ce qui se passe. Voil√† ce que je vois :

<div align="center">
<img src="./assets/image-19.webp" alt="" loading="lazy"/>
</div>


On voit qu'il y a aussi un probl√®me avec `MULTIBOOT_BOOTLOADER_MAGIC` qu'il ne connait pas. Je propose de commenter (CTRL + /) **toute et rien que** la fonction `sos_main(...)` existante et de copier le code ci-dessous √† sa suite :

```c
void sos_main(unsigned long magic, unsigned long addr) {
sos_bochs_setup();
sos_x86_videomem_setup();
sos_x86_videomem_cls(SOS_X86_VIDEO_BG_BLUE);
if (magic == MULTIBOOT2_BOOTLOADER_MAGIC) {
sos_x86_videomem_printf(0, 0,
SOS_X86_VIDEO_FG_YELLOW | SOS_X86_VIDEO_BG_BLUE,
"Valid magic number : 0x%x", (unsigned)magic);
} else {
sos_x86_videomem_printf(0, 0,
SOS_X86_VIDEO_FG_YELLOW | SOS_X86_VIDEO_BG_BLUE,
"Invalid magic number : 0x%x", (unsigned)magic);
}
sos_bochs_putstring("Message in a bochs");
for (;;)
continue;
return;
}
```

En fait il y a tr√®s peu de modifications. Cela dit, du point de vue de la r√©daction de ce billet c'est plus simple pour moi de montrer le code modifi√© plut√¥t que d'expliquer les changements √† appliquer :

* Au lieu de comparer `magic` √† `MULTIBOOT_BOOTLOADER_MAGIC` on le compare dor√©navant √† `MULTIBOOT2_BOOTLOADER_MAGIC` qui est d√©finit dans le fichier `sos/multiboot2.h`

* On utilise plus les structures de type `multiboot_info_t` et pour l'instant, on n'affiche pas d'information sur la m√©moire.

* Si on re√ßoit en param√®tre la bonne valeur de `magic` on confirme √† l'√©cran que SOS2 a √©t√© charg√© par Grub 2.

On relance un `make` dans le terminal. Nom de Zeus, Marty √ßa sent bon... Y a plus d'erreur.

<div align="center">
<img src="./assets/image-20.webp" alt="" width="900" loading="lazy"/>
</div>


En plus, dans un nouveau r√©pertoire `dist` on retrouve une image `sos2.iso`

<div align="center">
<img src="./assets/image-22.webp" alt="" loading="lazy"/>
</div>


On ne quitte pas le terminal docker. On en ouvre un nouveau dans lequel on tape :

```powershell
qemu-system-i386 -cdrom ./dist/sos2.iso
```

Le menu Grub 2 appara√Æt √† l'√©cran de la machine virtuelle et sos2 est bien l'option par d√©faut.

<div align="center">
<img src="./assets/image-23.webp" alt="" loading="lazy"/>
</div>


Si on ne fait rien pendant 5 secondes, la machine virtuelle boote sur sos2 et on obtient un message √† l'√©cran. √Ä priori `main.c` a re√ßu la bonne valeur dans le param√®tre `magic`. Le graaal!

<div align="center">
<img src="./assets/image-21.webp" alt="" loading="lazy"/>
</div>


Avant de faire le m√©nage dans les fichiers g√©n√©r√©s, je te propose d'utiliser ton gestionnaire de fichiers favori et d'aller te promener dans `dist/sos2.iso`. Par exemple, voil√† ce que je vois :

<div align="center">
<img src="./assets/image-27.webp" alt="" width="900" loading="lazy"/>
</div>


On comprend bien que l'image iso c'est la concat√©nation de `sos2.bin`, de `grub.cfg` et de tout un ensemble de fichiers qui sont apport√©s par Grub 2. Il faut prendre le temps d'aller visiter le sous-r√©pertoire `grub` ci-dessus. Il y a de tout : polices, locales, des tonnes de fichiers .mod etc.

On ferme la machine virtuelle, on retourne dans le terminal du container qui s'appelle docker et on lance la commande suivante :

```bash
root@74879c3dbefe:~/env# make clean
```

Normalement le projet est nettoy√©.

* Le r√©pertoire `dist` et son image iso ont disparus.

* Il n'y a plus de fichiers compil√©s dans le r√©pertoire `build`

* Le fichier `build.bin` a disparu lui aussi.

## **5 - Afficher les informations m√©moire**

Pour √™tre tout √† fait raccord avec l'√©pisode 1, il faut que SOS2 affiche les informations concernant la m√©moire de la machine dans laquelle il s'ex√©cute.

Je te propose de commenter la pr√©c√©dente fonction `sos_main(...)` et de rajouter le code ci-dessous √† sa suite :

```c
void sos_main(unsigned long magic, unsigned long addr) {
sos_bochs_setup();
sos_x86_videomem_setup();
sos_x86_videomem_cls(SOS_X86_VIDEO_BG_BLUE);
int line = 0;
line++;
if (magic == MULTIBOOT2_BOOTLOADER_MAGIC) {
sos_x86_videomem_printf(line, 0,
SOS_X86_VIDEO_FG_YELLOW | SOS_X86_VIDEO_BG_BLUE,
"Valid magic number : 0x%x", (unsigned)magic);
} else {
sos_x86_videomem_printf(line, 0,
SOS_X86_VIDEO_FG_YELLOW | SOS_X86_VIDEO_BG_BLUE,
"Invalid magic number : 0x%x", (unsigned)magic);
}
struct multiboot_tag *tag;
for (tag = (struct multiboot_tag *)(addr + 8);
tag->type != MULTIBOOT_TAG_TYPE_END;
tag = (struct multiboot_tag *)((multiboot_uint8_t *)tag +
((tag->size + 7) & ~7))) {
switch (tag->type) {
case MULTIBOOT_TAG_TYPE_BASIC_MEMINFO:
line++;
sos_x86_videomem_printf(
line, 0, SOS_X86_VIDEO_FG_YELLOW | SOS_X86_VIDEO_BG_BLUE,
"mem_lower : %d KB",
((struct multiboot_tag_basic_meminfo *)tag)->mem_lower);
line++;
sos_x86_videomem_printf(
line, 0, SOS_X86_VIDEO_FG_YELLOW | SOS_X86_VIDEO_BG_BLUE,
"mem_upper : %d KB",
((struct multiboot_tag_basic_meminfo *)tag)->mem_upper);
break;
}
}
sos_bochs_putstring("Message in a bochs");
for (;;)
continue;
return;
}
```

Ce code utilise une partie de ce qui est expliqu√© sur la page des [sp√©cifications de multiboot 2](https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html). Cette derni√®re √† l'air aust√®re mais franchement, elle se lit bien.

Oui, je sais, dans le code il y a une boucle `for` avec un `switch` qui ne comporte qu'un seul `case`. Pas la peine de r√¢ler ni de lever les yeux au ciel. On va se servir du `case` dans 2 minutes...

Quand le fichier `main.c` est sauvegard√©

* On relance un `make` dans le terminal du container

* On relance un `qemu-system-i386 -cdrom .\dist\sos2.iso` dans le terminal powershell

Voil√† ce que j'obtiens :

<div align="center">
<img src="./assets/image-24.webp" alt="" loading="lazy"/>
</div>


Si maintenant je relance un boot avec la ligne ci-dessous

```powershell
qemu-system-i386 -m 512M -cdrom .\dist\sos2.iso
```

Voil√† ce que je vois :

<div align="center">
<img src="./assets/image-25.webp" alt="" loading="lazy"/>
</div>


La machine virtuelle a dor√©navant 512 MB de RAM et cette information est pass√©e √† SOS2 par l'interm√©diaire de la multiboot info data structure (`multiboot_tag` dans le code de `sos_main.c`)

#### **S√©quence explications**

* Comme on peut le voir dans les [specs multiboot 2](https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html), la multiboot info data structure peut √™tre parcourue comme une liste chain√©e dont chaque maillon poss√®de un tag, une taille et des informations sp√©cifiques au tag en question.

* Du coup dans la boucle `for`, en fonction de la nature du tag, on ex√©cute tel ou tel `case`.

* Bien s√ªr le type de chaque tag est dans le fichier multiboot2.h. Par exemple si le type du tag vaut `MULTIBOOT_TAG_TYPE_END` c'est qu'on est arriv√© au bout de la "chaine". Sinon si il vaut `MULTIBOOT_TAG_TYPE_BASIC_MEMINFO` c'est que le tag est un pointeur sur une structure de type `multiboot_tag_basic_meminfo` dont on peut extraire les 2 valeurs etc.

* Cet hiver √ßa vaudra peut √™tre le coup de revenir sur la boucle `for`. Faut pas se laisser impressionner par les expressions du style `((tag->size + 7) & ~7))`. C'est juste des histoires de programmeurs. En effet, les tags sont √† des adresses m√©moires qui sont des multiples de 8 et `size` c'est la taille r√©elle, utile, du tag. Du coup il faut faire un peu d'arithm√©tique pour trouver l'adresse du prochain tag.

## **6 - Aller plus loin...**

Pour te donner envie d'aller lire la spec je te propose d'ajouter le code ci-dessous √† l'int√©rieur de la boucle `for` :

```c
case MULTIBOOT_TAG_TYPE_BOOT_LOADER_NAME:
line++;
sos_x86_videomem_printf(line, 0,
SOS_X86_VIDEO_FG_YELLOW | SOS_X86_VIDEO_BG_BLUE,
"Boot loader name : %s",
((struct multiboot_tag_string *)tag)->string);
break;
```

Quand le fichier `main.c` est sauvegard√© :

* Relance un `make` dans le terminal du container

* Relance un `qemu-system-i386` -m 512M `-cdrom .\dist\sos2.iso` dans le terminal powershell

Voil√† alors ce que j'obtiens :

<div align="center">
<img src="./assets/image-26.webp" alt="" loading="lazy"/>
</div>

## **7 - Optionel, uniquement si tu es joueur**

### **7.1 Placement en m√©moire**

L'objectif est de comprendre un peu mieux √† quoi sert le fichier `sos2.ld`. Voil√† l'organisation d'un programme en m√©moire. Dans les adresses les plus basses on retrouve le code puis directement au dessus les variables initialis√©es, les variables non initialis√©es, le tas (qui grandit vers le haut) et tout en haut, la pile qui grandit vers le bas.

<div align="center">
<img src="./assets/image-35.webp" alt="" loading="lazy"/>
</div>


Donc... M√™me si je n'ai pas une id√©e simple pour d√©terminer √† quelle adresse m√©moire est plac√© le d√©but du code noyau de SOS2, je peux approximer cette derni√®re en utilisant l'adresse d'une variable initialis√©e. En effet celle-ci sera plac√©e apr√®s le code ex√©cutable et donc son adresse sera obligatoirement sup√©rieure √† l'adresse de d√©part du code. Si ce dernier est court, la section `.text` sera courte et on devrait retrouver nos petits.

Je propose d'√©crire une nouvelle version de la fonction `sos_main(...)`. Ce noyau ne fait qu'afficher l'adresse de la variable `bob` qui est initialis√©e et qui, bien s√ªr, contient [la valeur 42](https://fr.wikipedia.org/wiki/La_grande_question_sur_la_vie%2C_l%27Univers_et_le_reste).

```c
void sos_main(unsigned long magic, unsigned long addr) {
sos_bochs_setup();
sos_x86_videomem_setup();
sos_x86_videomem_cls(SOS_X86_VIDEO_BG_BLUE);
int bob = 42;
sos_x86_videomem_printf(0, 0, SOS_X86_VIDEO_FG_YELLOW | SOS_X86_VIDEO_BG_BLUE,
"Adr of an initilized variable : 0x%x",
(unsigned)(&bob));
for (;;)
continue;
return;
}
```

Ensuite, on ne change rien. On garde `sos2.ld` en l'√©tat avec son point de chargement √† 1MB. Voir ci-dessous :

<div align="center">
<img src="./assets/image-31.webp" alt="" width="900" loading="lazy"/>
</div>


Je passe les d√©tails mais voil√† ce que l'on voit √† l'ex√©cution. Bonne nouvelle 0x104BF4 c'est bien au del√† de 1MB. Le noyau semble avoir √©t√© charg√© √† l'adresse 1MB.

<div align="center">
<img src="./assets/image-32.webp" alt="" width="900" loading="lazy"/>
</div>


Maintenant, on recompile et on relance le noyau mais en ayant modifi√© `sos2.ld` de la fa√ßon suivante (voir le `. = 3M;`) :

<div align="center">
<img src="./assets/image-33.webp" alt="" width="900" loading="lazy"/>
</div>


Bingo ! L'adresse de la variable `bob` est dor√©navant 0x304BF4 ce qui la situe au del√† des 3MB. Le noyau semble donc bien avoir √©t√© charg√© √† l'adresse 3MB.

<div align="center">
<img src="./assets/image-34.webp" alt="" width="900" loading="lazy"/>
</div>


Pour information, sur [OS Dev.org](https://wiki.osdev.org/Memory_Map_%28x86%29) on retrouve le mapping de la m√©moire d'un PC quand il est encore en mode r√©el. Vu le monde qu'il y a on comprend l'int√©r√™t qu'il y a √† placer rapidement le PC en mode prot√©g√© et √† placer le noyau de l'OS au-del√† de 1MB (0x100000)

<div align="center">
<img src="./assets/image-36.webp" alt="" width="900" loading="lazy"/>
</div>

### **7.2 Les diff√©rentes sections**

On ne touche pas au code, mais sur docker, au prompt, on invoque la commande suivante :

```plain
readelf -a ./target/iso/boot/sos2.bin
```

Voil√† ce que je vois

<div align="center">
<img src="./assets/image-1_2023_12.webp" alt="" loading="lazy"/>
</div>


On retrouve en partie ce dont il est question dans l'annexe A.1 de l'article initial. L'autre truc, c'est que si on remonte un peu dans le texte qui est √† l'√©cran, on peut voir ceci :

<div align="center">
<img src="./assets/image-2_2023_12.webp" alt="" loading="lazy"/>
</div>


C'est rassurant, sos2.bin est bien un code au format ELF32. De plus on apprend que le "Entry point" se situe √† l'adresse 0x300EE0 (au del√† des 3M donc). Enfin si on descend on peut voir que le point d'entree `start` est effectivement √† l'adresse 0x300EE0 :

<div align="center">
<img src="./assets/image-3.webp" alt="" loading="lazy"/>
</div>


Histoire de "jouer" avec l'organisation de notre binaire (sos.bin) je te propose de modifier `sos2.ld` comme suit :

* On repasse √† 2M

* On renomme la section .boot

```plain
ENTRY(start)
SECTIONS {
. = 2M;
.zoubida :
{
/* ensure that the multiboot header is at the beginning */
*(.multiboot_header)
}
.text :
{
*(.text)
}
}
```

Je fais court :

* make clean

* make

* qemu-system-i386 -cdrom ./dist/sos2.iso (c√¥t√© PowerShell pour se rassurer)

* readelf -a ./target/iso/boot/sos2.bin (c√¥t√© Docker)

Voil√† ce que je vois :

<div align="center">
<img src="./assets/image-4_2023_12.webp" alt="" loading="lazy"/>
</div>


On retrouve une section `.zoubida` en t√™te. C'est normal c'est la premi√®re du fichier `sos2.ld` et c'est ce que l'on veut. En effet elle contient le code √©tiquet√© `.multiboot_header` qui doit absolument √™tre dans les premiers 32k du binaire si on veut qu'il soit retrouv√© par Grub 2 (voir les specs de Grub2). Donc, le truc √† comprendre c'est que dans le fichier sos2.ld, ce qui compte, c'est l'ordre et qu'on a une certaine libert√© en ce qui concerne les noms de section.

Par contre on observe que des sections ont √©t√© rajout√©es. L√† aussi, il en est question dans l'annexe A.1 de l'article original :

* `.text` : code

* `.data` : variables initialis√©es

* `.rodata` : variables initialis√©es en lecture seule

* `.bss` : variables non initialis√©es

* `.symtab` : table des symboles

Par contre il y a des sections avec des noms de l'espace... `.shstrtab` (contient les noms de sections ?), `.comment`(?), `.eh_frame` (√ßa me fait penser aux exceptions C++, bizarre on est en C ANSI classique).

Afin de supprimer la section .eh_frame je te propose d'ajouter `-fno-asynchronous-unwind-tables` √† `CFLAGS` dans le fichier `Makefile` :

```plain
CFLAGS = -Wall -nostdlib -nostdinc -ffreestanding -m32 -fno-asynchronous-unwind-tables
```

Si on compile et qu'on liste les sections voil√† ce que je vois (`.eh_frame` a disparu, il n'y a plus que 10 sections de 0 √† 9) :

<div align="center">
<img src="./assets/image-5_2023_12.webp" alt="" loading="lazy"/>
</div>


On peut aller plus loin et se rapprocher de l'organisation du fichier `sos.lds` de l'article. N'oublie pas, tu as acc√®s √† ce fichier, il est dans `download\sos-code-article1\support\sos.lds`). Je te propose de modifier sos2.ld comme suit :

```plain
ENTRY(start)
SECTIONS {
. = 2M;
.zoubida :
{
/* ensure that the multiboot header is at the beginning */
*(.multiboot_header)
}
.text ALIGN(4096) :
{
*(.text)
}
.data . :
{
*(.data*)
}
.rodata . :
{
*(.rodata*)
}
.bss SIZEOF(.rodata) + ADDR(.rodata) :
{
*(.bss)
}
/DISCARD/ :{
*(.comment)
}
}
```

* J'ai gard√© zoubida. C'est cadeau, √ßa me fait plaisir...

* Sinon on aligne la section .text et on force l'ordre des sections .data, .rodata etc.

* Apr√®s faut aller potasser la syntaxe du script attendu par ld. Voir les liens √† la fin de cette section.

* C'est presque √©vident mais "`.text ALIGN(4096) :`" veut dire qu'il faut que la section `.text` commence au d√©but d'une page.

* De m√™me, le second "`.`" de "`.data . :`" demande √† ce que la section `.data` commence l√† o√π se termine la pr√©c√©dente section. Personnellement je comprend les "`.`" comme "les adresses de l√† o√π on est au moment o√π on les lis".

* Je passe les d√©tails mais √† la fin voil√† ce que l'on peut voir dans le terminal :

<div align="center">
<img src="./assets/image-6_2023_12.webp" alt="" loading="lazy"/>
</div>

#### **√Ä lire**

* <https://www.cs.princeton.edu/courses/archive/spring09/cos217/lectures/02_SimplePrograms.pdf>

* <https://man7.org/linux/man-pages/man5/elf.5.html>

* /DISCARD/ : <https://sourceware.org/binutils/docs/ld/Output-Section-Discarding.html>

Bon, allez, on va siffler la fin de la r√©cr√© car sinon on va y passer la nuit. Je te propose de passer dans le terminal du container, de faire un `make clean` suivit d'un `exit`, de repasser sur ton terminal puis de mettre tout √ßa sur [GitHub](https://github.com/40tude/sos2/tree/main) √† partir de VSCode.

## **Conclusion**

Si on prend un peu de recul, √† part `main.c` on a touch√© aucun des fichiers du r√©pertoire `sos`. M√™me chose pour les r√©pertoires `drivers` et `hwcore`. Oui, bien s√ªr, on a touch√© au r√©pertoire `bootstrap` mais bon, au final, on peut attaquer dans la joie et la bonne humeur les autres √©pisodes de la s√©rie. On a une toolchain moderne, solide, ind√©pendante de l'OS qui l'h√©berge... Et nom de Zeus, r√©alise qu'on a fait un peu de bouche √† bouche √† un code qui a 20 ans et zou il est reparti. Moi, perso, je trouve √ßa vraiment cool.

Maintenant, ce qui m'excite le plus, c'est d'attaquer le second √©pisode de la s√©rie qui traite de la segmentation m√©moire et des interruptions. J'ai h√¢te de voir comment l'adaptation va se passer. Cela fera sans doute l'objet d'un second billet de blog.

*Allez, √† plus et la suite au prochain √©pisode...*

### **PS-1 : Warnings lors du make sos2**

Si on lit attentivement tous les messages lors d'un make sos2, on peut voir les lignes suivantes :

```plain
ld: warning: build/multiboot_header.o: missing .note.GNU-stack section implies executable stack
ld: NOTE: This behaviour is deprecated and will be removed in a future version of the linker
ld: warning: target/iso/boot/sos2.bin has a LOAD segment with RWX permissions
```

Google est notre ami... Pour y rem√©dier je propose de faire 2 choses.

1 - Modifier le fichier sos2.ld comme ci-dessous :

```plain
ENTRY(start)
SECTIONS {
. = 2M;
.zoubida :
{
/* ensure that the multiboot header is at the beginning */
*(.multiboot_header)
}
.text : ALIGN(CONSTANT(MAXPAGESIZE))
{
*(.text)
}
.data : ALIGN(CONSTANT(MAXPAGESIZE))
{
*(.data*)
}
.rodata : ALIGN(CONSTANT(MAXPAGESIZE))
{
*(.rodata*)
}
.bss : ALIGN(CONSTANT(MAXPAGESIZE))
{
*(.bss)
}
/DISCARD/ :{
*(.comment)
}
}
```

On ne retrouve pas les `__b_load` et autres qu'il y avait dans le fichier `sos.lds` car ces symboles √©taient utilis√©s dans `multiboot.S` ou `sos_bsect.lds` (cas de `__b_load` par exemple). Comme ils ne sont pas utilis√©s jusqu'√† pr√©sent dans sos2, autant ne pas charger sos2.ld inutilement.

2 - Rajouter la ligne ci-dessous tout en bas des fichiers `multiboot.asm` et `multiboot_header.asm`.

```plain
section .note.GNU-stack noalloc noexec nowrite progbits ; https://wiki.gentoo.org/wiki/Hardened/GNU_stack_quickstart
; https://stackoverflow.com/questions/73435637/how-can-i-fix-usr-bin-ld-warning-trap-o-missing-note-gnu-stack-section-imp
```

Par exemple, voil√† ce √† quoi ressemble la fin de `multiboot_header.asm`

<div align="center">
<img src="./assets/image-37.webp" alt="" width="900" loading="lazy"/>
</div>

#### **√Ä lire**

* <https://osdev.org/Linker_Scripts> √† propos du warning RWX permissions et de la solution

* <https://www.redhat.com/en/blog/linkers-warnings-about-executable-stacks-and-segments>

### **PS-2 :**

√Ä l'attention des d√©veloppeurs du soi-disant "√©diteur" de WordPress... Je vous hais d'une force messieurs... Vous ne pouvez pas imaginer.

